13.2 原型模式的定义
原型模式（Prototype Pattern）的简单程度仅次于单例模式和迭代器模式。正是由于简
单，使用的场景才非常地多，其定义如下：
Specify the kinds of objects to create using a prototypical instance,and create new objects by
copying this prototype.（用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对
象。）

![原型模式的通用类图](https://pic.downk.cc/item/5f704c0f160a154a67aaa65d.jpg)

简单，太简单了！原型模式的核心是一个clone方法，通过该方法进行对象的拷贝，Java
提供了一个Cloneable接口来标示这个对象是可拷贝的，为什么说是“标示”呢？翻开JDK的帮
助看看Cloneable是一个方法都没有的，这个接口只是一个标记作用，在JVM中具有这个标记
的对象才有可能被拷贝。那怎么才能从“有可能被拷贝”转换为“可以被拷贝”呢？方法是覆盖
clone()方法，是的，你没有看错是重写clone()方法

13.3 原型模式的应用
13.3.1 原型模式的优点
● 性能优良
原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一
个循环体内产生大量的对象时，原型模式可以更好地体现其优点。
● 逃避构造函数的约束
这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的（参见13.4
节）。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑。

13.3.2 原型模式的使用场景
● 资源优化场景
类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。
● 性能和安全要求的场景
通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。
● 一个对象多个修改者的场景
一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑
使用原型模式拷贝多个对象供调用者使用。
在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的
方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与Java融为一体，大家可
以随手拿来使用。

13.4 原型模式的注意事项
13.4.1 构造函数不会被执行
对象拷贝时构造函数确实没有被执行，这点从原理来讲也是可以讲得通的，Object类的
clone方法的原理是从内存中（具体地说就是堆内存）以二进制流的方式进行拷贝，重新分配
一个内存块，那构造函数没有被执行也是非常正常的了。

13.4.2 浅拷贝和深拷贝
Object类提供的方法clone只是拷贝本对象，其对象内部的数组、引用对象等都不拷贝，还是指向原生对象
的内部元素地址，这种拷贝就叫做浅拷贝。确实是非常浅，两个对象共享了一个私有变量，
你改我改大家都能改，是一种非常不安全的方式，在实际项目中使用还是比较少的（当然，
这也是一种“危机”环境的一种救命方式）。你可能会比较奇怪，为什么在Mail那个类中就可
以使用String类型，而不会产生由浅拷贝带来的问题呢？内部的数组和引用对象才不拷贝，
其他的原始类型比如int、long、char等都会被拷贝，但是对于String类型，Java就希望你把它
认为是基本类型，它是没有clone方法的，处理机制也比较特殊，通过字符串池（stringpool）
在需要的时候才在内存中创建新的字符串，读者在使用的时候就把String当做基本类使用即可。
注意 深拷贝和浅拷贝建议不要混合使用，特别是在涉及类的继承时，父类有多个引用
的情况就非常复杂，建议的方案是深拷贝和浅拷贝分开实现。

13.4.3 clone与final两个冤家
注意 要使用clone方法，类的成员变量上不要增加final关键字。

